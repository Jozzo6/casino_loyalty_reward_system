// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"context"
	"sync"

	"github.com/Jozzo6/casino_loyalty_reward_system/internal/store"
	"github.com/Jozzo6/casino_loyalty_reward_system/internal/types"
	"github.com/google/uuid"
)

type FakePersistent struct {
	AddPromotionStub        func(context.Context, types.UserPromotion) (types.UserPromotion, error)
	addPromotionMutex       sync.RWMutex
	addPromotionArgsForCall []struct {
		arg1 context.Context
		arg2 types.UserPromotion
	}
	addPromotionReturns struct {
		result1 types.UserPromotion
		result2 error
	}
	addPromotionReturnsOnCall map[int]struct {
		result1 types.UserPromotion
		result2 error
	}
	ClaimPromotionStub        func(context.Context, uuid.UUID) error
	claimPromotionMutex       sync.RWMutex
	claimPromotionArgsForCall []struct {
		arg1 context.Context
		arg2 uuid.UUID
	}
	claimPromotionReturns struct {
		result1 error
	}
	claimPromotionReturnsOnCall map[int]struct {
		result1 error
	}
	CommitTxStub        func(context.Context) error
	commitTxMutex       sync.RWMutex
	commitTxArgsForCall []struct {
		arg1 context.Context
	}
	commitTxReturns struct {
		result1 error
	}
	commitTxReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteUserPromotionStub        func(context.Context, uuid.UUID) error
	deleteUserPromotionMutex       sync.RWMutex
	deleteUserPromotionArgsForCall []struct {
		arg1 context.Context
		arg2 uuid.UUID
	}
	deleteUserPromotionReturns struct {
		result1 error
	}
	deleteUserPromotionReturnsOnCall map[int]struct {
		result1 error
	}
	GetPromotionsStub        func(context.Context) ([]types.Promotion, error)
	getPromotionsMutex       sync.RWMutex
	getPromotionsArgsForCall []struct {
		arg1 context.Context
	}
	getPromotionsReturns struct {
		result1 []types.Promotion
		result2 error
	}
	getPromotionsReturnsOnCall map[int]struct {
		result1 []types.Promotion
		result2 error
	}
	GetUserPromotionByIDStub        func(context.Context, uuid.UUID) (types.UserPromotion, error)
	getUserPromotionByIDMutex       sync.RWMutex
	getUserPromotionByIDArgsForCall []struct {
		arg1 context.Context
		arg2 uuid.UUID
	}
	getUserPromotionByIDReturns struct {
		result1 types.UserPromotion
		result2 error
	}
	getUserPromotionByIDReturnsOnCall map[int]struct {
		result1 types.UserPromotion
		result2 error
	}
	GetUserPromotionsStub        func(context.Context, uuid.UUID) ([]types.UserPromotion, error)
	getUserPromotionsMutex       sync.RWMutex
	getUserPromotionsArgsForCall []struct {
		arg1 context.Context
		arg2 uuid.UUID
	}
	getUserPromotionsReturns struct {
		result1 []types.UserPromotion
		result2 error
	}
	getUserPromotionsReturnsOnCall map[int]struct {
		result1 []types.UserPromotion
		result2 error
	}
	GetUsersStub        func(context.Context) ([]types.User, error)
	getUsersMutex       sync.RWMutex
	getUsersArgsForCall []struct {
		arg1 context.Context
	}
	getUsersReturns struct {
		result1 []types.User
		result2 error
	}
	getUsersReturnsOnCall map[int]struct {
		result1 []types.User
		result2 error
	}
	PromotionCreateStub        func(context.Context, types.Promotion) (types.Promotion, error)
	promotionCreateMutex       sync.RWMutex
	promotionCreateArgsForCall []struct {
		arg1 context.Context
		arg2 types.Promotion
	}
	promotionCreateReturns struct {
		result1 types.Promotion
		result2 error
	}
	promotionCreateReturnsOnCall map[int]struct {
		result1 types.Promotion
		result2 error
	}
	PromotionDeleteStub        func(context.Context, uuid.UUID) error
	promotionDeleteMutex       sync.RWMutex
	promotionDeleteArgsForCall []struct {
		arg1 context.Context
		arg2 uuid.UUID
	}
	promotionDeleteReturns struct {
		result1 error
	}
	promotionDeleteReturnsOnCall map[int]struct {
		result1 error
	}
	PromotionGetByIDStub        func(context.Context, uuid.UUID) (types.Promotion, error)
	promotionGetByIDMutex       sync.RWMutex
	promotionGetByIDArgsForCall []struct {
		arg1 context.Context
		arg2 uuid.UUID
	}
	promotionGetByIDReturns struct {
		result1 types.Promotion
		result2 error
	}
	promotionGetByIDReturnsOnCall map[int]struct {
		result1 types.Promotion
		result2 error
	}
	PromotionGetByTypeStub        func(context.Context, types.PromotionType) (types.Promotion, error)
	promotionGetByTypeMutex       sync.RWMutex
	promotionGetByTypeArgsForCall []struct {
		arg1 context.Context
		arg2 types.PromotionType
	}
	promotionGetByTypeReturns struct {
		result1 types.Promotion
		result2 error
	}
	promotionGetByTypeReturnsOnCall map[int]struct {
		result1 types.Promotion
		result2 error
	}
	PromotionUpdateStub        func(context.Context, types.Promotion) (types.Promotion, error)
	promotionUpdateMutex       sync.RWMutex
	promotionUpdateArgsForCall []struct {
		arg1 context.Context
		arg2 types.Promotion
	}
	promotionUpdateReturns struct {
		result1 types.Promotion
		result2 error
	}
	promotionUpdateReturnsOnCall map[int]struct {
		result1 types.Promotion
		result2 error
	}
	RollbackTxStub        func(context.Context) error
	rollbackTxMutex       sync.RWMutex
	rollbackTxArgsForCall []struct {
		arg1 context.Context
	}
	rollbackTxReturns struct {
		result1 error
	}
	rollbackTxReturnsOnCall map[int]struct {
		result1 error
	}
	UserBalanceUpdateStub        func(context.Context, uuid.UUID, float64) (types.User, error)
	userBalanceUpdateMutex       sync.RWMutex
	userBalanceUpdateArgsForCall []struct {
		arg1 context.Context
		arg2 uuid.UUID
		arg3 float64
	}
	userBalanceUpdateReturns struct {
		result1 types.User
		result2 error
	}
	userBalanceUpdateReturnsOnCall map[int]struct {
		result1 types.User
		result2 error
	}
	UserCreateStub        func(context.Context, types.User) (types.User, error)
	userCreateMutex       sync.RWMutex
	userCreateArgsForCall []struct {
		arg1 context.Context
		arg2 types.User
	}
	userCreateReturns struct {
		result1 types.User
		result2 error
	}
	userCreateReturnsOnCall map[int]struct {
		result1 types.User
		result2 error
	}
	UserDeleteStub        func(context.Context, uuid.UUID) error
	userDeleteMutex       sync.RWMutex
	userDeleteArgsForCall []struct {
		arg1 context.Context
		arg2 uuid.UUID
	}
	userDeleteReturns struct {
		result1 error
	}
	userDeleteReturnsOnCall map[int]struct {
		result1 error
	}
	UserGetByStub        func(context.Context, types.UserFilter) (types.User, error)
	userGetByMutex       sync.RWMutex
	userGetByArgsForCall []struct {
		arg1 context.Context
		arg2 types.UserFilter
	}
	userGetByReturns struct {
		result1 types.User
		result2 error
	}
	userGetByReturnsOnCall map[int]struct {
		result1 types.User
		result2 error
	}
	UserUpdateStub        func(context.Context, types.User) (types.User, error)
	userUpdateMutex       sync.RWMutex
	userUpdateArgsForCall []struct {
		arg1 context.Context
		arg2 types.User
	}
	userUpdateReturns struct {
		result1 types.User
		result2 error
	}
	userUpdateReturnsOnCall map[int]struct {
		result1 types.User
		result2 error
	}
	WithTxStub        func(context.Context) (store.Persistent, error)
	withTxMutex       sync.RWMutex
	withTxArgsForCall []struct {
		arg1 context.Context
	}
	withTxReturns struct {
		result1 store.Persistent
		result2 error
	}
	withTxReturnsOnCall map[int]struct {
		result1 store.Persistent
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePersistent) AddPromotion(arg1 context.Context, arg2 types.UserPromotion) (types.UserPromotion, error) {
	fake.addPromotionMutex.Lock()
	ret, specificReturn := fake.addPromotionReturnsOnCall[len(fake.addPromotionArgsForCall)]
	fake.addPromotionArgsForCall = append(fake.addPromotionArgsForCall, struct {
		arg1 context.Context
		arg2 types.UserPromotion
	}{arg1, arg2})
	stub := fake.AddPromotionStub
	fakeReturns := fake.addPromotionReturns
	fake.recordInvocation("AddPromotion", []interface{}{arg1, arg2})
	fake.addPromotionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePersistent) AddPromotionCallCount() int {
	fake.addPromotionMutex.RLock()
	defer fake.addPromotionMutex.RUnlock()
	return len(fake.addPromotionArgsForCall)
}

func (fake *FakePersistent) AddPromotionCalls(stub func(context.Context, types.UserPromotion) (types.UserPromotion, error)) {
	fake.addPromotionMutex.Lock()
	defer fake.addPromotionMutex.Unlock()
	fake.AddPromotionStub = stub
}

func (fake *FakePersistent) AddPromotionArgsForCall(i int) (context.Context, types.UserPromotion) {
	fake.addPromotionMutex.RLock()
	defer fake.addPromotionMutex.RUnlock()
	argsForCall := fake.addPromotionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePersistent) AddPromotionReturns(result1 types.UserPromotion, result2 error) {
	fake.addPromotionMutex.Lock()
	defer fake.addPromotionMutex.Unlock()
	fake.AddPromotionStub = nil
	fake.addPromotionReturns = struct {
		result1 types.UserPromotion
		result2 error
	}{result1, result2}
}

func (fake *FakePersistent) AddPromotionReturnsOnCall(i int, result1 types.UserPromotion, result2 error) {
	fake.addPromotionMutex.Lock()
	defer fake.addPromotionMutex.Unlock()
	fake.AddPromotionStub = nil
	if fake.addPromotionReturnsOnCall == nil {
		fake.addPromotionReturnsOnCall = make(map[int]struct {
			result1 types.UserPromotion
			result2 error
		})
	}
	fake.addPromotionReturnsOnCall[i] = struct {
		result1 types.UserPromotion
		result2 error
	}{result1, result2}
}

func (fake *FakePersistent) ClaimPromotion(arg1 context.Context, arg2 uuid.UUID) error {
	fake.claimPromotionMutex.Lock()
	ret, specificReturn := fake.claimPromotionReturnsOnCall[len(fake.claimPromotionArgsForCall)]
	fake.claimPromotionArgsForCall = append(fake.claimPromotionArgsForCall, struct {
		arg1 context.Context
		arg2 uuid.UUID
	}{arg1, arg2})
	stub := fake.ClaimPromotionStub
	fakeReturns := fake.claimPromotionReturns
	fake.recordInvocation("ClaimPromotion", []interface{}{arg1, arg2})
	fake.claimPromotionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePersistent) ClaimPromotionCallCount() int {
	fake.claimPromotionMutex.RLock()
	defer fake.claimPromotionMutex.RUnlock()
	return len(fake.claimPromotionArgsForCall)
}

func (fake *FakePersistent) ClaimPromotionCalls(stub func(context.Context, uuid.UUID) error) {
	fake.claimPromotionMutex.Lock()
	defer fake.claimPromotionMutex.Unlock()
	fake.ClaimPromotionStub = stub
}

func (fake *FakePersistent) ClaimPromotionArgsForCall(i int) (context.Context, uuid.UUID) {
	fake.claimPromotionMutex.RLock()
	defer fake.claimPromotionMutex.RUnlock()
	argsForCall := fake.claimPromotionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePersistent) ClaimPromotionReturns(result1 error) {
	fake.claimPromotionMutex.Lock()
	defer fake.claimPromotionMutex.Unlock()
	fake.ClaimPromotionStub = nil
	fake.claimPromotionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePersistent) ClaimPromotionReturnsOnCall(i int, result1 error) {
	fake.claimPromotionMutex.Lock()
	defer fake.claimPromotionMutex.Unlock()
	fake.ClaimPromotionStub = nil
	if fake.claimPromotionReturnsOnCall == nil {
		fake.claimPromotionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.claimPromotionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePersistent) CommitTx(arg1 context.Context) error {
	fake.commitTxMutex.Lock()
	ret, specificReturn := fake.commitTxReturnsOnCall[len(fake.commitTxArgsForCall)]
	fake.commitTxArgsForCall = append(fake.commitTxArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.CommitTxStub
	fakeReturns := fake.commitTxReturns
	fake.recordInvocation("CommitTx", []interface{}{arg1})
	fake.commitTxMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePersistent) CommitTxCallCount() int {
	fake.commitTxMutex.RLock()
	defer fake.commitTxMutex.RUnlock()
	return len(fake.commitTxArgsForCall)
}

func (fake *FakePersistent) CommitTxCalls(stub func(context.Context) error) {
	fake.commitTxMutex.Lock()
	defer fake.commitTxMutex.Unlock()
	fake.CommitTxStub = stub
}

func (fake *FakePersistent) CommitTxArgsForCall(i int) context.Context {
	fake.commitTxMutex.RLock()
	defer fake.commitTxMutex.RUnlock()
	argsForCall := fake.commitTxArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePersistent) CommitTxReturns(result1 error) {
	fake.commitTxMutex.Lock()
	defer fake.commitTxMutex.Unlock()
	fake.CommitTxStub = nil
	fake.commitTxReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePersistent) CommitTxReturnsOnCall(i int, result1 error) {
	fake.commitTxMutex.Lock()
	defer fake.commitTxMutex.Unlock()
	fake.CommitTxStub = nil
	if fake.commitTxReturnsOnCall == nil {
		fake.commitTxReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.commitTxReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePersistent) DeleteUserPromotion(arg1 context.Context, arg2 uuid.UUID) error {
	fake.deleteUserPromotionMutex.Lock()
	ret, specificReturn := fake.deleteUserPromotionReturnsOnCall[len(fake.deleteUserPromotionArgsForCall)]
	fake.deleteUserPromotionArgsForCall = append(fake.deleteUserPromotionArgsForCall, struct {
		arg1 context.Context
		arg2 uuid.UUID
	}{arg1, arg2})
	stub := fake.DeleteUserPromotionStub
	fakeReturns := fake.deleteUserPromotionReturns
	fake.recordInvocation("DeleteUserPromotion", []interface{}{arg1, arg2})
	fake.deleteUserPromotionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePersistent) DeleteUserPromotionCallCount() int {
	fake.deleteUserPromotionMutex.RLock()
	defer fake.deleteUserPromotionMutex.RUnlock()
	return len(fake.deleteUserPromotionArgsForCall)
}

func (fake *FakePersistent) DeleteUserPromotionCalls(stub func(context.Context, uuid.UUID) error) {
	fake.deleteUserPromotionMutex.Lock()
	defer fake.deleteUserPromotionMutex.Unlock()
	fake.DeleteUserPromotionStub = stub
}

func (fake *FakePersistent) DeleteUserPromotionArgsForCall(i int) (context.Context, uuid.UUID) {
	fake.deleteUserPromotionMutex.RLock()
	defer fake.deleteUserPromotionMutex.RUnlock()
	argsForCall := fake.deleteUserPromotionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePersistent) DeleteUserPromotionReturns(result1 error) {
	fake.deleteUserPromotionMutex.Lock()
	defer fake.deleteUserPromotionMutex.Unlock()
	fake.DeleteUserPromotionStub = nil
	fake.deleteUserPromotionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePersistent) DeleteUserPromotionReturnsOnCall(i int, result1 error) {
	fake.deleteUserPromotionMutex.Lock()
	defer fake.deleteUserPromotionMutex.Unlock()
	fake.DeleteUserPromotionStub = nil
	if fake.deleteUserPromotionReturnsOnCall == nil {
		fake.deleteUserPromotionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteUserPromotionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePersistent) GetPromotions(arg1 context.Context) ([]types.Promotion, error) {
	fake.getPromotionsMutex.Lock()
	ret, specificReturn := fake.getPromotionsReturnsOnCall[len(fake.getPromotionsArgsForCall)]
	fake.getPromotionsArgsForCall = append(fake.getPromotionsArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.GetPromotionsStub
	fakeReturns := fake.getPromotionsReturns
	fake.recordInvocation("GetPromotions", []interface{}{arg1})
	fake.getPromotionsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePersistent) GetPromotionsCallCount() int {
	fake.getPromotionsMutex.RLock()
	defer fake.getPromotionsMutex.RUnlock()
	return len(fake.getPromotionsArgsForCall)
}

func (fake *FakePersistent) GetPromotionsCalls(stub func(context.Context) ([]types.Promotion, error)) {
	fake.getPromotionsMutex.Lock()
	defer fake.getPromotionsMutex.Unlock()
	fake.GetPromotionsStub = stub
}

func (fake *FakePersistent) GetPromotionsArgsForCall(i int) context.Context {
	fake.getPromotionsMutex.RLock()
	defer fake.getPromotionsMutex.RUnlock()
	argsForCall := fake.getPromotionsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePersistent) GetPromotionsReturns(result1 []types.Promotion, result2 error) {
	fake.getPromotionsMutex.Lock()
	defer fake.getPromotionsMutex.Unlock()
	fake.GetPromotionsStub = nil
	fake.getPromotionsReturns = struct {
		result1 []types.Promotion
		result2 error
	}{result1, result2}
}

func (fake *FakePersistent) GetPromotionsReturnsOnCall(i int, result1 []types.Promotion, result2 error) {
	fake.getPromotionsMutex.Lock()
	defer fake.getPromotionsMutex.Unlock()
	fake.GetPromotionsStub = nil
	if fake.getPromotionsReturnsOnCall == nil {
		fake.getPromotionsReturnsOnCall = make(map[int]struct {
			result1 []types.Promotion
			result2 error
		})
	}
	fake.getPromotionsReturnsOnCall[i] = struct {
		result1 []types.Promotion
		result2 error
	}{result1, result2}
}

func (fake *FakePersistent) GetUserPromotionByID(arg1 context.Context, arg2 uuid.UUID) (types.UserPromotion, error) {
	fake.getUserPromotionByIDMutex.Lock()
	ret, specificReturn := fake.getUserPromotionByIDReturnsOnCall[len(fake.getUserPromotionByIDArgsForCall)]
	fake.getUserPromotionByIDArgsForCall = append(fake.getUserPromotionByIDArgsForCall, struct {
		arg1 context.Context
		arg2 uuid.UUID
	}{arg1, arg2})
	stub := fake.GetUserPromotionByIDStub
	fakeReturns := fake.getUserPromotionByIDReturns
	fake.recordInvocation("GetUserPromotionByID", []interface{}{arg1, arg2})
	fake.getUserPromotionByIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePersistent) GetUserPromotionByIDCallCount() int {
	fake.getUserPromotionByIDMutex.RLock()
	defer fake.getUserPromotionByIDMutex.RUnlock()
	return len(fake.getUserPromotionByIDArgsForCall)
}

func (fake *FakePersistent) GetUserPromotionByIDCalls(stub func(context.Context, uuid.UUID) (types.UserPromotion, error)) {
	fake.getUserPromotionByIDMutex.Lock()
	defer fake.getUserPromotionByIDMutex.Unlock()
	fake.GetUserPromotionByIDStub = stub
}

func (fake *FakePersistent) GetUserPromotionByIDArgsForCall(i int) (context.Context, uuid.UUID) {
	fake.getUserPromotionByIDMutex.RLock()
	defer fake.getUserPromotionByIDMutex.RUnlock()
	argsForCall := fake.getUserPromotionByIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePersistent) GetUserPromotionByIDReturns(result1 types.UserPromotion, result2 error) {
	fake.getUserPromotionByIDMutex.Lock()
	defer fake.getUserPromotionByIDMutex.Unlock()
	fake.GetUserPromotionByIDStub = nil
	fake.getUserPromotionByIDReturns = struct {
		result1 types.UserPromotion
		result2 error
	}{result1, result2}
}

func (fake *FakePersistent) GetUserPromotionByIDReturnsOnCall(i int, result1 types.UserPromotion, result2 error) {
	fake.getUserPromotionByIDMutex.Lock()
	defer fake.getUserPromotionByIDMutex.Unlock()
	fake.GetUserPromotionByIDStub = nil
	if fake.getUserPromotionByIDReturnsOnCall == nil {
		fake.getUserPromotionByIDReturnsOnCall = make(map[int]struct {
			result1 types.UserPromotion
			result2 error
		})
	}
	fake.getUserPromotionByIDReturnsOnCall[i] = struct {
		result1 types.UserPromotion
		result2 error
	}{result1, result2}
}

func (fake *FakePersistent) GetUserPromotions(arg1 context.Context, arg2 uuid.UUID) ([]types.UserPromotion, error) {
	fake.getUserPromotionsMutex.Lock()
	ret, specificReturn := fake.getUserPromotionsReturnsOnCall[len(fake.getUserPromotionsArgsForCall)]
	fake.getUserPromotionsArgsForCall = append(fake.getUserPromotionsArgsForCall, struct {
		arg1 context.Context
		arg2 uuid.UUID
	}{arg1, arg2})
	stub := fake.GetUserPromotionsStub
	fakeReturns := fake.getUserPromotionsReturns
	fake.recordInvocation("GetUserPromotions", []interface{}{arg1, arg2})
	fake.getUserPromotionsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePersistent) GetUserPromotionsCallCount() int {
	fake.getUserPromotionsMutex.RLock()
	defer fake.getUserPromotionsMutex.RUnlock()
	return len(fake.getUserPromotionsArgsForCall)
}

func (fake *FakePersistent) GetUserPromotionsCalls(stub func(context.Context, uuid.UUID) ([]types.UserPromotion, error)) {
	fake.getUserPromotionsMutex.Lock()
	defer fake.getUserPromotionsMutex.Unlock()
	fake.GetUserPromotionsStub = stub
}

func (fake *FakePersistent) GetUserPromotionsArgsForCall(i int) (context.Context, uuid.UUID) {
	fake.getUserPromotionsMutex.RLock()
	defer fake.getUserPromotionsMutex.RUnlock()
	argsForCall := fake.getUserPromotionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePersistent) GetUserPromotionsReturns(result1 []types.UserPromotion, result2 error) {
	fake.getUserPromotionsMutex.Lock()
	defer fake.getUserPromotionsMutex.Unlock()
	fake.GetUserPromotionsStub = nil
	fake.getUserPromotionsReturns = struct {
		result1 []types.UserPromotion
		result2 error
	}{result1, result2}
}

func (fake *FakePersistent) GetUserPromotionsReturnsOnCall(i int, result1 []types.UserPromotion, result2 error) {
	fake.getUserPromotionsMutex.Lock()
	defer fake.getUserPromotionsMutex.Unlock()
	fake.GetUserPromotionsStub = nil
	if fake.getUserPromotionsReturnsOnCall == nil {
		fake.getUserPromotionsReturnsOnCall = make(map[int]struct {
			result1 []types.UserPromotion
			result2 error
		})
	}
	fake.getUserPromotionsReturnsOnCall[i] = struct {
		result1 []types.UserPromotion
		result2 error
	}{result1, result2}
}

func (fake *FakePersistent) GetUsers(arg1 context.Context) ([]types.User, error) {
	fake.getUsersMutex.Lock()
	ret, specificReturn := fake.getUsersReturnsOnCall[len(fake.getUsersArgsForCall)]
	fake.getUsersArgsForCall = append(fake.getUsersArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.GetUsersStub
	fakeReturns := fake.getUsersReturns
	fake.recordInvocation("GetUsers", []interface{}{arg1})
	fake.getUsersMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePersistent) GetUsersCallCount() int {
	fake.getUsersMutex.RLock()
	defer fake.getUsersMutex.RUnlock()
	return len(fake.getUsersArgsForCall)
}

func (fake *FakePersistent) GetUsersCalls(stub func(context.Context) ([]types.User, error)) {
	fake.getUsersMutex.Lock()
	defer fake.getUsersMutex.Unlock()
	fake.GetUsersStub = stub
}

func (fake *FakePersistent) GetUsersArgsForCall(i int) context.Context {
	fake.getUsersMutex.RLock()
	defer fake.getUsersMutex.RUnlock()
	argsForCall := fake.getUsersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePersistent) GetUsersReturns(result1 []types.User, result2 error) {
	fake.getUsersMutex.Lock()
	defer fake.getUsersMutex.Unlock()
	fake.GetUsersStub = nil
	fake.getUsersReturns = struct {
		result1 []types.User
		result2 error
	}{result1, result2}
}

func (fake *FakePersistent) GetUsersReturnsOnCall(i int, result1 []types.User, result2 error) {
	fake.getUsersMutex.Lock()
	defer fake.getUsersMutex.Unlock()
	fake.GetUsersStub = nil
	if fake.getUsersReturnsOnCall == nil {
		fake.getUsersReturnsOnCall = make(map[int]struct {
			result1 []types.User
			result2 error
		})
	}
	fake.getUsersReturnsOnCall[i] = struct {
		result1 []types.User
		result2 error
	}{result1, result2}
}

func (fake *FakePersistent) PromotionCreate(arg1 context.Context, arg2 types.Promotion) (types.Promotion, error) {
	fake.promotionCreateMutex.Lock()
	ret, specificReturn := fake.promotionCreateReturnsOnCall[len(fake.promotionCreateArgsForCall)]
	fake.promotionCreateArgsForCall = append(fake.promotionCreateArgsForCall, struct {
		arg1 context.Context
		arg2 types.Promotion
	}{arg1, arg2})
	stub := fake.PromotionCreateStub
	fakeReturns := fake.promotionCreateReturns
	fake.recordInvocation("PromotionCreate", []interface{}{arg1, arg2})
	fake.promotionCreateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePersistent) PromotionCreateCallCount() int {
	fake.promotionCreateMutex.RLock()
	defer fake.promotionCreateMutex.RUnlock()
	return len(fake.promotionCreateArgsForCall)
}

func (fake *FakePersistent) PromotionCreateCalls(stub func(context.Context, types.Promotion) (types.Promotion, error)) {
	fake.promotionCreateMutex.Lock()
	defer fake.promotionCreateMutex.Unlock()
	fake.PromotionCreateStub = stub
}

func (fake *FakePersistent) PromotionCreateArgsForCall(i int) (context.Context, types.Promotion) {
	fake.promotionCreateMutex.RLock()
	defer fake.promotionCreateMutex.RUnlock()
	argsForCall := fake.promotionCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePersistent) PromotionCreateReturns(result1 types.Promotion, result2 error) {
	fake.promotionCreateMutex.Lock()
	defer fake.promotionCreateMutex.Unlock()
	fake.PromotionCreateStub = nil
	fake.promotionCreateReturns = struct {
		result1 types.Promotion
		result2 error
	}{result1, result2}
}

func (fake *FakePersistent) PromotionCreateReturnsOnCall(i int, result1 types.Promotion, result2 error) {
	fake.promotionCreateMutex.Lock()
	defer fake.promotionCreateMutex.Unlock()
	fake.PromotionCreateStub = nil
	if fake.promotionCreateReturnsOnCall == nil {
		fake.promotionCreateReturnsOnCall = make(map[int]struct {
			result1 types.Promotion
			result2 error
		})
	}
	fake.promotionCreateReturnsOnCall[i] = struct {
		result1 types.Promotion
		result2 error
	}{result1, result2}
}

func (fake *FakePersistent) PromotionDelete(arg1 context.Context, arg2 uuid.UUID) error {
	fake.promotionDeleteMutex.Lock()
	ret, specificReturn := fake.promotionDeleteReturnsOnCall[len(fake.promotionDeleteArgsForCall)]
	fake.promotionDeleteArgsForCall = append(fake.promotionDeleteArgsForCall, struct {
		arg1 context.Context
		arg2 uuid.UUID
	}{arg1, arg2})
	stub := fake.PromotionDeleteStub
	fakeReturns := fake.promotionDeleteReturns
	fake.recordInvocation("PromotionDelete", []interface{}{arg1, arg2})
	fake.promotionDeleteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePersistent) PromotionDeleteCallCount() int {
	fake.promotionDeleteMutex.RLock()
	defer fake.promotionDeleteMutex.RUnlock()
	return len(fake.promotionDeleteArgsForCall)
}

func (fake *FakePersistent) PromotionDeleteCalls(stub func(context.Context, uuid.UUID) error) {
	fake.promotionDeleteMutex.Lock()
	defer fake.promotionDeleteMutex.Unlock()
	fake.PromotionDeleteStub = stub
}

func (fake *FakePersistent) PromotionDeleteArgsForCall(i int) (context.Context, uuid.UUID) {
	fake.promotionDeleteMutex.RLock()
	defer fake.promotionDeleteMutex.RUnlock()
	argsForCall := fake.promotionDeleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePersistent) PromotionDeleteReturns(result1 error) {
	fake.promotionDeleteMutex.Lock()
	defer fake.promotionDeleteMutex.Unlock()
	fake.PromotionDeleteStub = nil
	fake.promotionDeleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePersistent) PromotionDeleteReturnsOnCall(i int, result1 error) {
	fake.promotionDeleteMutex.Lock()
	defer fake.promotionDeleteMutex.Unlock()
	fake.PromotionDeleteStub = nil
	if fake.promotionDeleteReturnsOnCall == nil {
		fake.promotionDeleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.promotionDeleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePersistent) PromotionGetByID(arg1 context.Context, arg2 uuid.UUID) (types.Promotion, error) {
	fake.promotionGetByIDMutex.Lock()
	ret, specificReturn := fake.promotionGetByIDReturnsOnCall[len(fake.promotionGetByIDArgsForCall)]
	fake.promotionGetByIDArgsForCall = append(fake.promotionGetByIDArgsForCall, struct {
		arg1 context.Context
		arg2 uuid.UUID
	}{arg1, arg2})
	stub := fake.PromotionGetByIDStub
	fakeReturns := fake.promotionGetByIDReturns
	fake.recordInvocation("PromotionGetByID", []interface{}{arg1, arg2})
	fake.promotionGetByIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePersistent) PromotionGetByIDCallCount() int {
	fake.promotionGetByIDMutex.RLock()
	defer fake.promotionGetByIDMutex.RUnlock()
	return len(fake.promotionGetByIDArgsForCall)
}

func (fake *FakePersistent) PromotionGetByIDCalls(stub func(context.Context, uuid.UUID) (types.Promotion, error)) {
	fake.promotionGetByIDMutex.Lock()
	defer fake.promotionGetByIDMutex.Unlock()
	fake.PromotionGetByIDStub = stub
}

func (fake *FakePersistent) PromotionGetByIDArgsForCall(i int) (context.Context, uuid.UUID) {
	fake.promotionGetByIDMutex.RLock()
	defer fake.promotionGetByIDMutex.RUnlock()
	argsForCall := fake.promotionGetByIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePersistent) PromotionGetByIDReturns(result1 types.Promotion, result2 error) {
	fake.promotionGetByIDMutex.Lock()
	defer fake.promotionGetByIDMutex.Unlock()
	fake.PromotionGetByIDStub = nil
	fake.promotionGetByIDReturns = struct {
		result1 types.Promotion
		result2 error
	}{result1, result2}
}

func (fake *FakePersistent) PromotionGetByIDReturnsOnCall(i int, result1 types.Promotion, result2 error) {
	fake.promotionGetByIDMutex.Lock()
	defer fake.promotionGetByIDMutex.Unlock()
	fake.PromotionGetByIDStub = nil
	if fake.promotionGetByIDReturnsOnCall == nil {
		fake.promotionGetByIDReturnsOnCall = make(map[int]struct {
			result1 types.Promotion
			result2 error
		})
	}
	fake.promotionGetByIDReturnsOnCall[i] = struct {
		result1 types.Promotion
		result2 error
	}{result1, result2}
}

func (fake *FakePersistent) PromotionGetByType(arg1 context.Context, arg2 types.PromotionType) (types.Promotion, error) {
	fake.promotionGetByTypeMutex.Lock()
	ret, specificReturn := fake.promotionGetByTypeReturnsOnCall[len(fake.promotionGetByTypeArgsForCall)]
	fake.promotionGetByTypeArgsForCall = append(fake.promotionGetByTypeArgsForCall, struct {
		arg1 context.Context
		arg2 types.PromotionType
	}{arg1, arg2})
	stub := fake.PromotionGetByTypeStub
	fakeReturns := fake.promotionGetByTypeReturns
	fake.recordInvocation("PromotionGetByType", []interface{}{arg1, arg2})
	fake.promotionGetByTypeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePersistent) PromotionGetByTypeCallCount() int {
	fake.promotionGetByTypeMutex.RLock()
	defer fake.promotionGetByTypeMutex.RUnlock()
	return len(fake.promotionGetByTypeArgsForCall)
}

func (fake *FakePersistent) PromotionGetByTypeCalls(stub func(context.Context, types.PromotionType) (types.Promotion, error)) {
	fake.promotionGetByTypeMutex.Lock()
	defer fake.promotionGetByTypeMutex.Unlock()
	fake.PromotionGetByTypeStub = stub
}

func (fake *FakePersistent) PromotionGetByTypeArgsForCall(i int) (context.Context, types.PromotionType) {
	fake.promotionGetByTypeMutex.RLock()
	defer fake.promotionGetByTypeMutex.RUnlock()
	argsForCall := fake.promotionGetByTypeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePersistent) PromotionGetByTypeReturns(result1 types.Promotion, result2 error) {
	fake.promotionGetByTypeMutex.Lock()
	defer fake.promotionGetByTypeMutex.Unlock()
	fake.PromotionGetByTypeStub = nil
	fake.promotionGetByTypeReturns = struct {
		result1 types.Promotion
		result2 error
	}{result1, result2}
}

func (fake *FakePersistent) PromotionGetByTypeReturnsOnCall(i int, result1 types.Promotion, result2 error) {
	fake.promotionGetByTypeMutex.Lock()
	defer fake.promotionGetByTypeMutex.Unlock()
	fake.PromotionGetByTypeStub = nil
	if fake.promotionGetByTypeReturnsOnCall == nil {
		fake.promotionGetByTypeReturnsOnCall = make(map[int]struct {
			result1 types.Promotion
			result2 error
		})
	}
	fake.promotionGetByTypeReturnsOnCall[i] = struct {
		result1 types.Promotion
		result2 error
	}{result1, result2}
}

func (fake *FakePersistent) PromotionUpdate(arg1 context.Context, arg2 types.Promotion) (types.Promotion, error) {
	fake.promotionUpdateMutex.Lock()
	ret, specificReturn := fake.promotionUpdateReturnsOnCall[len(fake.promotionUpdateArgsForCall)]
	fake.promotionUpdateArgsForCall = append(fake.promotionUpdateArgsForCall, struct {
		arg1 context.Context
		arg2 types.Promotion
	}{arg1, arg2})
	stub := fake.PromotionUpdateStub
	fakeReturns := fake.promotionUpdateReturns
	fake.recordInvocation("PromotionUpdate", []interface{}{arg1, arg2})
	fake.promotionUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePersistent) PromotionUpdateCallCount() int {
	fake.promotionUpdateMutex.RLock()
	defer fake.promotionUpdateMutex.RUnlock()
	return len(fake.promotionUpdateArgsForCall)
}

func (fake *FakePersistent) PromotionUpdateCalls(stub func(context.Context, types.Promotion) (types.Promotion, error)) {
	fake.promotionUpdateMutex.Lock()
	defer fake.promotionUpdateMutex.Unlock()
	fake.PromotionUpdateStub = stub
}

func (fake *FakePersistent) PromotionUpdateArgsForCall(i int) (context.Context, types.Promotion) {
	fake.promotionUpdateMutex.RLock()
	defer fake.promotionUpdateMutex.RUnlock()
	argsForCall := fake.promotionUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePersistent) PromotionUpdateReturns(result1 types.Promotion, result2 error) {
	fake.promotionUpdateMutex.Lock()
	defer fake.promotionUpdateMutex.Unlock()
	fake.PromotionUpdateStub = nil
	fake.promotionUpdateReturns = struct {
		result1 types.Promotion
		result2 error
	}{result1, result2}
}

func (fake *FakePersistent) PromotionUpdateReturnsOnCall(i int, result1 types.Promotion, result2 error) {
	fake.promotionUpdateMutex.Lock()
	defer fake.promotionUpdateMutex.Unlock()
	fake.PromotionUpdateStub = nil
	if fake.promotionUpdateReturnsOnCall == nil {
		fake.promotionUpdateReturnsOnCall = make(map[int]struct {
			result1 types.Promotion
			result2 error
		})
	}
	fake.promotionUpdateReturnsOnCall[i] = struct {
		result1 types.Promotion
		result2 error
	}{result1, result2}
}

func (fake *FakePersistent) RollbackTx(arg1 context.Context) error {
	fake.rollbackTxMutex.Lock()
	ret, specificReturn := fake.rollbackTxReturnsOnCall[len(fake.rollbackTxArgsForCall)]
	fake.rollbackTxArgsForCall = append(fake.rollbackTxArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.RollbackTxStub
	fakeReturns := fake.rollbackTxReturns
	fake.recordInvocation("RollbackTx", []interface{}{arg1})
	fake.rollbackTxMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePersistent) RollbackTxCallCount() int {
	fake.rollbackTxMutex.RLock()
	defer fake.rollbackTxMutex.RUnlock()
	return len(fake.rollbackTxArgsForCall)
}

func (fake *FakePersistent) RollbackTxCalls(stub func(context.Context) error) {
	fake.rollbackTxMutex.Lock()
	defer fake.rollbackTxMutex.Unlock()
	fake.RollbackTxStub = stub
}

func (fake *FakePersistent) RollbackTxArgsForCall(i int) context.Context {
	fake.rollbackTxMutex.RLock()
	defer fake.rollbackTxMutex.RUnlock()
	argsForCall := fake.rollbackTxArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePersistent) RollbackTxReturns(result1 error) {
	fake.rollbackTxMutex.Lock()
	defer fake.rollbackTxMutex.Unlock()
	fake.RollbackTxStub = nil
	fake.rollbackTxReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePersistent) RollbackTxReturnsOnCall(i int, result1 error) {
	fake.rollbackTxMutex.Lock()
	defer fake.rollbackTxMutex.Unlock()
	fake.RollbackTxStub = nil
	if fake.rollbackTxReturnsOnCall == nil {
		fake.rollbackTxReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.rollbackTxReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePersistent) UserBalanceUpdate(arg1 context.Context, arg2 uuid.UUID, arg3 float64) (types.User, error) {
	fake.userBalanceUpdateMutex.Lock()
	ret, specificReturn := fake.userBalanceUpdateReturnsOnCall[len(fake.userBalanceUpdateArgsForCall)]
	fake.userBalanceUpdateArgsForCall = append(fake.userBalanceUpdateArgsForCall, struct {
		arg1 context.Context
		arg2 uuid.UUID
		arg3 float64
	}{arg1, arg2, arg3})
	stub := fake.UserBalanceUpdateStub
	fakeReturns := fake.userBalanceUpdateReturns
	fake.recordInvocation("UserBalanceUpdate", []interface{}{arg1, arg2, arg3})
	fake.userBalanceUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePersistent) UserBalanceUpdateCallCount() int {
	fake.userBalanceUpdateMutex.RLock()
	defer fake.userBalanceUpdateMutex.RUnlock()
	return len(fake.userBalanceUpdateArgsForCall)
}

func (fake *FakePersistent) UserBalanceUpdateCalls(stub func(context.Context, uuid.UUID, float64) (types.User, error)) {
	fake.userBalanceUpdateMutex.Lock()
	defer fake.userBalanceUpdateMutex.Unlock()
	fake.UserBalanceUpdateStub = stub
}

func (fake *FakePersistent) UserBalanceUpdateArgsForCall(i int) (context.Context, uuid.UUID, float64) {
	fake.userBalanceUpdateMutex.RLock()
	defer fake.userBalanceUpdateMutex.RUnlock()
	argsForCall := fake.userBalanceUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePersistent) UserBalanceUpdateReturns(result1 types.User, result2 error) {
	fake.userBalanceUpdateMutex.Lock()
	defer fake.userBalanceUpdateMutex.Unlock()
	fake.UserBalanceUpdateStub = nil
	fake.userBalanceUpdateReturns = struct {
		result1 types.User
		result2 error
	}{result1, result2}
}

func (fake *FakePersistent) UserBalanceUpdateReturnsOnCall(i int, result1 types.User, result2 error) {
	fake.userBalanceUpdateMutex.Lock()
	defer fake.userBalanceUpdateMutex.Unlock()
	fake.UserBalanceUpdateStub = nil
	if fake.userBalanceUpdateReturnsOnCall == nil {
		fake.userBalanceUpdateReturnsOnCall = make(map[int]struct {
			result1 types.User
			result2 error
		})
	}
	fake.userBalanceUpdateReturnsOnCall[i] = struct {
		result1 types.User
		result2 error
	}{result1, result2}
}

func (fake *FakePersistent) UserCreate(arg1 context.Context, arg2 types.User) (types.User, error) {
	fake.userCreateMutex.Lock()
	ret, specificReturn := fake.userCreateReturnsOnCall[len(fake.userCreateArgsForCall)]
	fake.userCreateArgsForCall = append(fake.userCreateArgsForCall, struct {
		arg1 context.Context
		arg2 types.User
	}{arg1, arg2})
	stub := fake.UserCreateStub
	fakeReturns := fake.userCreateReturns
	fake.recordInvocation("UserCreate", []interface{}{arg1, arg2})
	fake.userCreateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePersistent) UserCreateCallCount() int {
	fake.userCreateMutex.RLock()
	defer fake.userCreateMutex.RUnlock()
	return len(fake.userCreateArgsForCall)
}

func (fake *FakePersistent) UserCreateCalls(stub func(context.Context, types.User) (types.User, error)) {
	fake.userCreateMutex.Lock()
	defer fake.userCreateMutex.Unlock()
	fake.UserCreateStub = stub
}

func (fake *FakePersistent) UserCreateArgsForCall(i int) (context.Context, types.User) {
	fake.userCreateMutex.RLock()
	defer fake.userCreateMutex.RUnlock()
	argsForCall := fake.userCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePersistent) UserCreateReturns(result1 types.User, result2 error) {
	fake.userCreateMutex.Lock()
	defer fake.userCreateMutex.Unlock()
	fake.UserCreateStub = nil
	fake.userCreateReturns = struct {
		result1 types.User
		result2 error
	}{result1, result2}
}

func (fake *FakePersistent) UserCreateReturnsOnCall(i int, result1 types.User, result2 error) {
	fake.userCreateMutex.Lock()
	defer fake.userCreateMutex.Unlock()
	fake.UserCreateStub = nil
	if fake.userCreateReturnsOnCall == nil {
		fake.userCreateReturnsOnCall = make(map[int]struct {
			result1 types.User
			result2 error
		})
	}
	fake.userCreateReturnsOnCall[i] = struct {
		result1 types.User
		result2 error
	}{result1, result2}
}

func (fake *FakePersistent) UserDelete(arg1 context.Context, arg2 uuid.UUID) error {
	fake.userDeleteMutex.Lock()
	ret, specificReturn := fake.userDeleteReturnsOnCall[len(fake.userDeleteArgsForCall)]
	fake.userDeleteArgsForCall = append(fake.userDeleteArgsForCall, struct {
		arg1 context.Context
		arg2 uuid.UUID
	}{arg1, arg2})
	stub := fake.UserDeleteStub
	fakeReturns := fake.userDeleteReturns
	fake.recordInvocation("UserDelete", []interface{}{arg1, arg2})
	fake.userDeleteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePersistent) UserDeleteCallCount() int {
	fake.userDeleteMutex.RLock()
	defer fake.userDeleteMutex.RUnlock()
	return len(fake.userDeleteArgsForCall)
}

func (fake *FakePersistent) UserDeleteCalls(stub func(context.Context, uuid.UUID) error) {
	fake.userDeleteMutex.Lock()
	defer fake.userDeleteMutex.Unlock()
	fake.UserDeleteStub = stub
}

func (fake *FakePersistent) UserDeleteArgsForCall(i int) (context.Context, uuid.UUID) {
	fake.userDeleteMutex.RLock()
	defer fake.userDeleteMutex.RUnlock()
	argsForCall := fake.userDeleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePersistent) UserDeleteReturns(result1 error) {
	fake.userDeleteMutex.Lock()
	defer fake.userDeleteMutex.Unlock()
	fake.UserDeleteStub = nil
	fake.userDeleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePersistent) UserDeleteReturnsOnCall(i int, result1 error) {
	fake.userDeleteMutex.Lock()
	defer fake.userDeleteMutex.Unlock()
	fake.UserDeleteStub = nil
	if fake.userDeleteReturnsOnCall == nil {
		fake.userDeleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.userDeleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePersistent) UserGetBy(arg1 context.Context, arg2 types.UserFilter) (types.User, error) {
	fake.userGetByMutex.Lock()
	ret, specificReturn := fake.userGetByReturnsOnCall[len(fake.userGetByArgsForCall)]
	fake.userGetByArgsForCall = append(fake.userGetByArgsForCall, struct {
		arg1 context.Context
		arg2 types.UserFilter
	}{arg1, arg2})
	stub := fake.UserGetByStub
	fakeReturns := fake.userGetByReturns
	fake.recordInvocation("UserGetBy", []interface{}{arg1, arg2})
	fake.userGetByMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePersistent) UserGetByCallCount() int {
	fake.userGetByMutex.RLock()
	defer fake.userGetByMutex.RUnlock()
	return len(fake.userGetByArgsForCall)
}

func (fake *FakePersistent) UserGetByCalls(stub func(context.Context, types.UserFilter) (types.User, error)) {
	fake.userGetByMutex.Lock()
	defer fake.userGetByMutex.Unlock()
	fake.UserGetByStub = stub
}

func (fake *FakePersistent) UserGetByArgsForCall(i int) (context.Context, types.UserFilter) {
	fake.userGetByMutex.RLock()
	defer fake.userGetByMutex.RUnlock()
	argsForCall := fake.userGetByArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePersistent) UserGetByReturns(result1 types.User, result2 error) {
	fake.userGetByMutex.Lock()
	defer fake.userGetByMutex.Unlock()
	fake.UserGetByStub = nil
	fake.userGetByReturns = struct {
		result1 types.User
		result2 error
	}{result1, result2}
}

func (fake *FakePersistent) UserGetByReturnsOnCall(i int, result1 types.User, result2 error) {
	fake.userGetByMutex.Lock()
	defer fake.userGetByMutex.Unlock()
	fake.UserGetByStub = nil
	if fake.userGetByReturnsOnCall == nil {
		fake.userGetByReturnsOnCall = make(map[int]struct {
			result1 types.User
			result2 error
		})
	}
	fake.userGetByReturnsOnCall[i] = struct {
		result1 types.User
		result2 error
	}{result1, result2}
}

func (fake *FakePersistent) UserUpdate(arg1 context.Context, arg2 types.User) (types.User, error) {
	fake.userUpdateMutex.Lock()
	ret, specificReturn := fake.userUpdateReturnsOnCall[len(fake.userUpdateArgsForCall)]
	fake.userUpdateArgsForCall = append(fake.userUpdateArgsForCall, struct {
		arg1 context.Context
		arg2 types.User
	}{arg1, arg2})
	stub := fake.UserUpdateStub
	fakeReturns := fake.userUpdateReturns
	fake.recordInvocation("UserUpdate", []interface{}{arg1, arg2})
	fake.userUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePersistent) UserUpdateCallCount() int {
	fake.userUpdateMutex.RLock()
	defer fake.userUpdateMutex.RUnlock()
	return len(fake.userUpdateArgsForCall)
}

func (fake *FakePersistent) UserUpdateCalls(stub func(context.Context, types.User) (types.User, error)) {
	fake.userUpdateMutex.Lock()
	defer fake.userUpdateMutex.Unlock()
	fake.UserUpdateStub = stub
}

func (fake *FakePersistent) UserUpdateArgsForCall(i int) (context.Context, types.User) {
	fake.userUpdateMutex.RLock()
	defer fake.userUpdateMutex.RUnlock()
	argsForCall := fake.userUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePersistent) UserUpdateReturns(result1 types.User, result2 error) {
	fake.userUpdateMutex.Lock()
	defer fake.userUpdateMutex.Unlock()
	fake.UserUpdateStub = nil
	fake.userUpdateReturns = struct {
		result1 types.User
		result2 error
	}{result1, result2}
}

func (fake *FakePersistent) UserUpdateReturnsOnCall(i int, result1 types.User, result2 error) {
	fake.userUpdateMutex.Lock()
	defer fake.userUpdateMutex.Unlock()
	fake.UserUpdateStub = nil
	if fake.userUpdateReturnsOnCall == nil {
		fake.userUpdateReturnsOnCall = make(map[int]struct {
			result1 types.User
			result2 error
		})
	}
	fake.userUpdateReturnsOnCall[i] = struct {
		result1 types.User
		result2 error
	}{result1, result2}
}

func (fake *FakePersistent) WithTx(arg1 context.Context) (store.Persistent, error) {
	fake.withTxMutex.Lock()
	ret, specificReturn := fake.withTxReturnsOnCall[len(fake.withTxArgsForCall)]
	fake.withTxArgsForCall = append(fake.withTxArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.WithTxStub
	fakeReturns := fake.withTxReturns
	fake.recordInvocation("WithTx", []interface{}{arg1})
	fake.withTxMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePersistent) WithTxCallCount() int {
	fake.withTxMutex.RLock()
	defer fake.withTxMutex.RUnlock()
	return len(fake.withTxArgsForCall)
}

func (fake *FakePersistent) WithTxCalls(stub func(context.Context) (store.Persistent, error)) {
	fake.withTxMutex.Lock()
	defer fake.withTxMutex.Unlock()
	fake.WithTxStub = stub
}

func (fake *FakePersistent) WithTxArgsForCall(i int) context.Context {
	fake.withTxMutex.RLock()
	defer fake.withTxMutex.RUnlock()
	argsForCall := fake.withTxArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePersistent) WithTxReturns(result1 store.Persistent, result2 error) {
	fake.withTxMutex.Lock()
	defer fake.withTxMutex.Unlock()
	fake.WithTxStub = nil
	fake.withTxReturns = struct {
		result1 store.Persistent
		result2 error
	}{result1, result2}
}

func (fake *FakePersistent) WithTxReturnsOnCall(i int, result1 store.Persistent, result2 error) {
	fake.withTxMutex.Lock()
	defer fake.withTxMutex.Unlock()
	fake.WithTxStub = nil
	if fake.withTxReturnsOnCall == nil {
		fake.withTxReturnsOnCall = make(map[int]struct {
			result1 store.Persistent
			result2 error
		})
	}
	fake.withTxReturnsOnCall[i] = struct {
		result1 store.Persistent
		result2 error
	}{result1, result2}
}

func (fake *FakePersistent) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addPromotionMutex.RLock()
	defer fake.addPromotionMutex.RUnlock()
	fake.claimPromotionMutex.RLock()
	defer fake.claimPromotionMutex.RUnlock()
	fake.commitTxMutex.RLock()
	defer fake.commitTxMutex.RUnlock()
	fake.deleteUserPromotionMutex.RLock()
	defer fake.deleteUserPromotionMutex.RUnlock()
	fake.getPromotionsMutex.RLock()
	defer fake.getPromotionsMutex.RUnlock()
	fake.getUserPromotionByIDMutex.RLock()
	defer fake.getUserPromotionByIDMutex.RUnlock()
	fake.getUserPromotionsMutex.RLock()
	defer fake.getUserPromotionsMutex.RUnlock()
	fake.getUsersMutex.RLock()
	defer fake.getUsersMutex.RUnlock()
	fake.promotionCreateMutex.RLock()
	defer fake.promotionCreateMutex.RUnlock()
	fake.promotionDeleteMutex.RLock()
	defer fake.promotionDeleteMutex.RUnlock()
	fake.promotionGetByIDMutex.RLock()
	defer fake.promotionGetByIDMutex.RUnlock()
	fake.promotionGetByTypeMutex.RLock()
	defer fake.promotionGetByTypeMutex.RUnlock()
	fake.promotionUpdateMutex.RLock()
	defer fake.promotionUpdateMutex.RUnlock()
	fake.rollbackTxMutex.RLock()
	defer fake.rollbackTxMutex.RUnlock()
	fake.userBalanceUpdateMutex.RLock()
	defer fake.userBalanceUpdateMutex.RUnlock()
	fake.userCreateMutex.RLock()
	defer fake.userCreateMutex.RUnlock()
	fake.userDeleteMutex.RLock()
	defer fake.userDeleteMutex.RUnlock()
	fake.userGetByMutex.RLock()
	defer fake.userGetByMutex.RUnlock()
	fake.userUpdateMutex.RLock()
	defer fake.userUpdateMutex.RUnlock()
	fake.withTxMutex.RLock()
	defer fake.withTxMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakePersistent) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ store.Persistent = new(FakePersistent)
