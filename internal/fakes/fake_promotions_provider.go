// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"context"
	"sync"

	"github.com/Jozzo6/casino_loyalty_reward_system/internal/component/promotions"
	"github.com/Jozzo6/casino_loyalty_reward_system/internal/types"
	"github.com/google/uuid"
)

type FakePromotionProvider struct {
	CreatePromotionsStub        func(context.Context, types.Promotion) (types.Promotion, error)
	createPromotionsMutex       sync.RWMutex
	createPromotionsArgsForCall []struct {
		arg1 context.Context
		arg2 types.Promotion
	}
	createPromotionsReturns struct {
		result1 types.Promotion
		result2 error
	}
	createPromotionsReturnsOnCall map[int]struct {
		result1 types.Promotion
		result2 error
	}
	DeletePromotionStub        func(context.Context, uuid.UUID) error
	deletePromotionMutex       sync.RWMutex
	deletePromotionArgsForCall []struct {
		arg1 context.Context
		arg2 uuid.UUID
	}
	deletePromotionReturns struct {
		result1 error
	}
	deletePromotionReturnsOnCall map[int]struct {
		result1 error
	}
	GetPromotionByIDStub        func(context.Context, uuid.UUID) (types.Promotion, error)
	getPromotionByIDMutex       sync.RWMutex
	getPromotionByIDArgsForCall []struct {
		arg1 context.Context
		arg2 uuid.UUID
	}
	getPromotionByIDReturns struct {
		result1 types.Promotion
		result2 error
	}
	getPromotionByIDReturnsOnCall map[int]struct {
		result1 types.Promotion
		result2 error
	}
	GetPromotionsStub        func(context.Context) ([]types.Promotion, error)
	getPromotionsMutex       sync.RWMutex
	getPromotionsArgsForCall []struct {
		arg1 context.Context
	}
	getPromotionsReturns struct {
		result1 []types.Promotion
		result2 error
	}
	getPromotionsReturnsOnCall map[int]struct {
		result1 []types.Promotion
		result2 error
	}
	UpdatePromotionStub        func(context.Context, types.Promotion) (types.Promotion, error)
	updatePromotionMutex       sync.RWMutex
	updatePromotionArgsForCall []struct {
		arg1 context.Context
		arg2 types.Promotion
	}
	updatePromotionReturns struct {
		result1 types.Promotion
		result2 error
	}
	updatePromotionReturnsOnCall map[int]struct {
		result1 types.Promotion
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePromotionProvider) CreatePromotions(arg1 context.Context, arg2 types.Promotion) (types.Promotion, error) {
	fake.createPromotionsMutex.Lock()
	ret, specificReturn := fake.createPromotionsReturnsOnCall[len(fake.createPromotionsArgsForCall)]
	fake.createPromotionsArgsForCall = append(fake.createPromotionsArgsForCall, struct {
		arg1 context.Context
		arg2 types.Promotion
	}{arg1, arg2})
	stub := fake.CreatePromotionsStub
	fakeReturns := fake.createPromotionsReturns
	fake.recordInvocation("CreatePromotions", []interface{}{arg1, arg2})
	fake.createPromotionsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePromotionProvider) CreatePromotionsCallCount() int {
	fake.createPromotionsMutex.RLock()
	defer fake.createPromotionsMutex.RUnlock()
	return len(fake.createPromotionsArgsForCall)
}

func (fake *FakePromotionProvider) CreatePromotionsCalls(stub func(context.Context, types.Promotion) (types.Promotion, error)) {
	fake.createPromotionsMutex.Lock()
	defer fake.createPromotionsMutex.Unlock()
	fake.CreatePromotionsStub = stub
}

func (fake *FakePromotionProvider) CreatePromotionsArgsForCall(i int) (context.Context, types.Promotion) {
	fake.createPromotionsMutex.RLock()
	defer fake.createPromotionsMutex.RUnlock()
	argsForCall := fake.createPromotionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePromotionProvider) CreatePromotionsReturns(result1 types.Promotion, result2 error) {
	fake.createPromotionsMutex.Lock()
	defer fake.createPromotionsMutex.Unlock()
	fake.CreatePromotionsStub = nil
	fake.createPromotionsReturns = struct {
		result1 types.Promotion
		result2 error
	}{result1, result2}
}

func (fake *FakePromotionProvider) CreatePromotionsReturnsOnCall(i int, result1 types.Promotion, result2 error) {
	fake.createPromotionsMutex.Lock()
	defer fake.createPromotionsMutex.Unlock()
	fake.CreatePromotionsStub = nil
	if fake.createPromotionsReturnsOnCall == nil {
		fake.createPromotionsReturnsOnCall = make(map[int]struct {
			result1 types.Promotion
			result2 error
		})
	}
	fake.createPromotionsReturnsOnCall[i] = struct {
		result1 types.Promotion
		result2 error
	}{result1, result2}
}

func (fake *FakePromotionProvider) DeletePromotion(arg1 context.Context, arg2 uuid.UUID) error {
	fake.deletePromotionMutex.Lock()
	ret, specificReturn := fake.deletePromotionReturnsOnCall[len(fake.deletePromotionArgsForCall)]
	fake.deletePromotionArgsForCall = append(fake.deletePromotionArgsForCall, struct {
		arg1 context.Context
		arg2 uuid.UUID
	}{arg1, arg2})
	stub := fake.DeletePromotionStub
	fakeReturns := fake.deletePromotionReturns
	fake.recordInvocation("DeletePromotion", []interface{}{arg1, arg2})
	fake.deletePromotionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePromotionProvider) DeletePromotionCallCount() int {
	fake.deletePromotionMutex.RLock()
	defer fake.deletePromotionMutex.RUnlock()
	return len(fake.deletePromotionArgsForCall)
}

func (fake *FakePromotionProvider) DeletePromotionCalls(stub func(context.Context, uuid.UUID) error) {
	fake.deletePromotionMutex.Lock()
	defer fake.deletePromotionMutex.Unlock()
	fake.DeletePromotionStub = stub
}

func (fake *FakePromotionProvider) DeletePromotionArgsForCall(i int) (context.Context, uuid.UUID) {
	fake.deletePromotionMutex.RLock()
	defer fake.deletePromotionMutex.RUnlock()
	argsForCall := fake.deletePromotionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePromotionProvider) DeletePromotionReturns(result1 error) {
	fake.deletePromotionMutex.Lock()
	defer fake.deletePromotionMutex.Unlock()
	fake.DeletePromotionStub = nil
	fake.deletePromotionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePromotionProvider) DeletePromotionReturnsOnCall(i int, result1 error) {
	fake.deletePromotionMutex.Lock()
	defer fake.deletePromotionMutex.Unlock()
	fake.DeletePromotionStub = nil
	if fake.deletePromotionReturnsOnCall == nil {
		fake.deletePromotionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deletePromotionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePromotionProvider) GetPromotionByID(arg1 context.Context, arg2 uuid.UUID) (types.Promotion, error) {
	fake.getPromotionByIDMutex.Lock()
	ret, specificReturn := fake.getPromotionByIDReturnsOnCall[len(fake.getPromotionByIDArgsForCall)]
	fake.getPromotionByIDArgsForCall = append(fake.getPromotionByIDArgsForCall, struct {
		arg1 context.Context
		arg2 uuid.UUID
	}{arg1, arg2})
	stub := fake.GetPromotionByIDStub
	fakeReturns := fake.getPromotionByIDReturns
	fake.recordInvocation("GetPromotionByID", []interface{}{arg1, arg2})
	fake.getPromotionByIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePromotionProvider) GetPromotionByIDCallCount() int {
	fake.getPromotionByIDMutex.RLock()
	defer fake.getPromotionByIDMutex.RUnlock()
	return len(fake.getPromotionByIDArgsForCall)
}

func (fake *FakePromotionProvider) GetPromotionByIDCalls(stub func(context.Context, uuid.UUID) (types.Promotion, error)) {
	fake.getPromotionByIDMutex.Lock()
	defer fake.getPromotionByIDMutex.Unlock()
	fake.GetPromotionByIDStub = stub
}

func (fake *FakePromotionProvider) GetPromotionByIDArgsForCall(i int) (context.Context, uuid.UUID) {
	fake.getPromotionByIDMutex.RLock()
	defer fake.getPromotionByIDMutex.RUnlock()
	argsForCall := fake.getPromotionByIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePromotionProvider) GetPromotionByIDReturns(result1 types.Promotion, result2 error) {
	fake.getPromotionByIDMutex.Lock()
	defer fake.getPromotionByIDMutex.Unlock()
	fake.GetPromotionByIDStub = nil
	fake.getPromotionByIDReturns = struct {
		result1 types.Promotion
		result2 error
	}{result1, result2}
}

func (fake *FakePromotionProvider) GetPromotionByIDReturnsOnCall(i int, result1 types.Promotion, result2 error) {
	fake.getPromotionByIDMutex.Lock()
	defer fake.getPromotionByIDMutex.Unlock()
	fake.GetPromotionByIDStub = nil
	if fake.getPromotionByIDReturnsOnCall == nil {
		fake.getPromotionByIDReturnsOnCall = make(map[int]struct {
			result1 types.Promotion
			result2 error
		})
	}
	fake.getPromotionByIDReturnsOnCall[i] = struct {
		result1 types.Promotion
		result2 error
	}{result1, result2}
}

func (fake *FakePromotionProvider) GetPromotions(arg1 context.Context) ([]types.Promotion, error) {
	fake.getPromotionsMutex.Lock()
	ret, specificReturn := fake.getPromotionsReturnsOnCall[len(fake.getPromotionsArgsForCall)]
	fake.getPromotionsArgsForCall = append(fake.getPromotionsArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.GetPromotionsStub
	fakeReturns := fake.getPromotionsReturns
	fake.recordInvocation("GetPromotions", []interface{}{arg1})
	fake.getPromotionsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePromotionProvider) GetPromotionsCallCount() int {
	fake.getPromotionsMutex.RLock()
	defer fake.getPromotionsMutex.RUnlock()
	return len(fake.getPromotionsArgsForCall)
}

func (fake *FakePromotionProvider) GetPromotionsCalls(stub func(context.Context) ([]types.Promotion, error)) {
	fake.getPromotionsMutex.Lock()
	defer fake.getPromotionsMutex.Unlock()
	fake.GetPromotionsStub = stub
}

func (fake *FakePromotionProvider) GetPromotionsArgsForCall(i int) context.Context {
	fake.getPromotionsMutex.RLock()
	defer fake.getPromotionsMutex.RUnlock()
	argsForCall := fake.getPromotionsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePromotionProvider) GetPromotionsReturns(result1 []types.Promotion, result2 error) {
	fake.getPromotionsMutex.Lock()
	defer fake.getPromotionsMutex.Unlock()
	fake.GetPromotionsStub = nil
	fake.getPromotionsReturns = struct {
		result1 []types.Promotion
		result2 error
	}{result1, result2}
}

func (fake *FakePromotionProvider) GetPromotionsReturnsOnCall(i int, result1 []types.Promotion, result2 error) {
	fake.getPromotionsMutex.Lock()
	defer fake.getPromotionsMutex.Unlock()
	fake.GetPromotionsStub = nil
	if fake.getPromotionsReturnsOnCall == nil {
		fake.getPromotionsReturnsOnCall = make(map[int]struct {
			result1 []types.Promotion
			result2 error
		})
	}
	fake.getPromotionsReturnsOnCall[i] = struct {
		result1 []types.Promotion
		result2 error
	}{result1, result2}
}

func (fake *FakePromotionProvider) UpdatePromotion(arg1 context.Context, arg2 types.Promotion) (types.Promotion, error) {
	fake.updatePromotionMutex.Lock()
	ret, specificReturn := fake.updatePromotionReturnsOnCall[len(fake.updatePromotionArgsForCall)]
	fake.updatePromotionArgsForCall = append(fake.updatePromotionArgsForCall, struct {
		arg1 context.Context
		arg2 types.Promotion
	}{arg1, arg2})
	stub := fake.UpdatePromotionStub
	fakeReturns := fake.updatePromotionReturns
	fake.recordInvocation("UpdatePromotion", []interface{}{arg1, arg2})
	fake.updatePromotionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePromotionProvider) UpdatePromotionCallCount() int {
	fake.updatePromotionMutex.RLock()
	defer fake.updatePromotionMutex.RUnlock()
	return len(fake.updatePromotionArgsForCall)
}

func (fake *FakePromotionProvider) UpdatePromotionCalls(stub func(context.Context, types.Promotion) (types.Promotion, error)) {
	fake.updatePromotionMutex.Lock()
	defer fake.updatePromotionMutex.Unlock()
	fake.UpdatePromotionStub = stub
}

func (fake *FakePromotionProvider) UpdatePromotionArgsForCall(i int) (context.Context, types.Promotion) {
	fake.updatePromotionMutex.RLock()
	defer fake.updatePromotionMutex.RUnlock()
	argsForCall := fake.updatePromotionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePromotionProvider) UpdatePromotionReturns(result1 types.Promotion, result2 error) {
	fake.updatePromotionMutex.Lock()
	defer fake.updatePromotionMutex.Unlock()
	fake.UpdatePromotionStub = nil
	fake.updatePromotionReturns = struct {
		result1 types.Promotion
		result2 error
	}{result1, result2}
}

func (fake *FakePromotionProvider) UpdatePromotionReturnsOnCall(i int, result1 types.Promotion, result2 error) {
	fake.updatePromotionMutex.Lock()
	defer fake.updatePromotionMutex.Unlock()
	fake.UpdatePromotionStub = nil
	if fake.updatePromotionReturnsOnCall == nil {
		fake.updatePromotionReturnsOnCall = make(map[int]struct {
			result1 types.Promotion
			result2 error
		})
	}
	fake.updatePromotionReturnsOnCall[i] = struct {
		result1 types.Promotion
		result2 error
	}{result1, result2}
}

func (fake *FakePromotionProvider) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createPromotionsMutex.RLock()
	defer fake.createPromotionsMutex.RUnlock()
	fake.deletePromotionMutex.RLock()
	defer fake.deletePromotionMutex.RUnlock()
	fake.getPromotionByIDMutex.RLock()
	defer fake.getPromotionByIDMutex.RUnlock()
	fake.getPromotionsMutex.RLock()
	defer fake.getPromotionsMutex.RUnlock()
	fake.updatePromotionMutex.RLock()
	defer fake.updatePromotionMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakePromotionProvider) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ promotions.PromotionProvider = new(FakePromotionProvider)
